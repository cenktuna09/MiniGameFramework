# ðŸŽ¯ Cursor Rules for MiniGameFramework-Unity6

global:
  - Always follow SOLID principles and Unity 6 best practices.
  - Use clean modular architecture: Core systems must be independent of MiniGames.
  - No hard dependencies between MiniGames and Core (use MiniGameBase + EventBus).
  - Prefer composition over inheritance except for MiniGameBase.
  - Use async/await for scene loading (Unity 6 Task-based SceneManager).
  - Favor record structs for lightweight data objects (Tiles, etc.).
  - Use descriptive names; avoid unnecessary abbreviations.
  - Always add XML doc comments for public classes and methods.
  - Keep methods under 50 lines; split responsibilities into smaller functions.

paths:
  - path: Assets/Core/**
    rules:
      - Core must not reference specific MiniGames.
      - Follow Dependency Inversion: Core depends on abstractions, not concrete MiniGames.
      - All core services must be bound via Zenject or custom DI. Avoid new singletons outside DI.

  - path: Assets/MiniGames/**
    rules:
      - Each mini-game must extend MiniGameBase.
      - No direct references to other mini-games.
      - Keep game-specific logic encapsulated in its folder.

  - path: Assets/Scenes/**
    rules:
      - Scenes should be minimal and rely on GameManager for flow.
      - Avoid hardcoding scene names; use constants or config.

  - path: Assets/UI/**
    rules:
      - UI logic must remain in UI layer only.
      - No direct game logic in UI components; communicate via events or GameManager.
      - Panels should be reusable across mini-games.

review:
  - Always check for SRP violations and suggest refactors.
  - Point out performance pitfalls (GC allocations, Update misuse).
  - Ensure EventBus usage stays decoupled.
  - Check PlayerPrefs usage goes only through SaveSystem.
  - Verify DI is correctly applied; no hidden static dependencies.

design:
  - When generating or refactoring code, always evaluate if there is a more modular, scalable, or maintainable alternative that better fits the project goals.
  - If such an alternative exists, propose it explicitly before implementing.
  - Alternatives should follow SOLID, decoupled architecture and Unity 6 performance best practices.
  - Clearly explain why the alternative is superior (testability, extensibility, performance, maintainability).

addressables:
  - All scenes and runtime assets must use Addressables for loading/unloading.
  - Avoid direct references in inspectors for dynamic content; prefer Addressable references.

match3:
  - Board generation must ensure:
      - No pre-existing matches at game start.
      - At least one valid move is always available.
  - Use constraint-based algorithm to validate tiles during generation.

endlessrunner:
  - Player movement must use Unity's new Input System for extensibility (mobile + PC).
  - Movement logic should be framerate-independent (use deltaTime or FixedUpdate).
  - Use object pooling for obstacles to avoid GC spikes during gameplay.
  - Level generation must be modular (segment-based or procedural chunks).
  - Game speed scaling should be handled via a configurable curve or difficulty manager.
  - Avoid heavy physics if not needed; prefer lightweight colliders and simple triggers.
  - Keep RunnerManager responsible only for game flow; PlayerController handles input/movement, Spawner handles obstacles.

performance:
  - All Update loops must be reviewed for GC allocations.
  - Prefer event-driven or coroutine-based alternatives where possible.
  - Use object pooling for frequently spawned/destroyed objects.

testing:
  - Every major system must have a comprehensive Tester class (like UIFrameworkTester, GameStateManagerTester).
  - Tester classes should include: bootstrap integration tests, functional tests, edge case tests, manual controls.
  - Auto-create test scenes with Unity MenuItem: "MiniGameFramework/Setup/Create [System] Test Scene".
  - Test systems must provide: real-time UI displays, pass/fail tracking, automated test sequences, manual control buttons.
  - All tests should run automatically on scene start with configurable intervals.
  - Event system integration must be tested in every tester (subscribe/publish verification).
  - Use reflection and GameObject.Find for automatic UI component assignment in test setup.
  - Test results should show detailed pass/fail counts and comprehensive logging.
  - Performance testing: ensure 60 FPS stability during all test sequences.
  - Test cleanup: properly dispose event subscriptions and reset systems.