# üèÉ‚Äç‚ôÇÔ∏è EndlessRunner Development Rules & Philosophy

## üéØ Core Development Philosophy

### **Primary Principle: Clear Code Structure > Amount of Features**
- Focus on modular, maintainable, and testable code over feature quantity
- Prioritize clean architecture and SOLID principles
- Build scalable foundation before adding complex features

### **Architecture Guidelines**
- **Hybrid Core Systems**: Use Core/Common base classes for shared functionality
- **Event-Driven Architecture**: Implement loose coupling via EventBus
- **Single Responsibility**: Each class should have one clear purpose
- **Dependency Injection**: Use ServiceLocator for service resolution
- **Base Class Leverage**: Extend Core/Common base classes for game-specific implementations

## üìù Coding Standards

### **Comment Style**
- Always comment with `#` symbol
- Use English for all comments and explanations
- Explain code functionality in English during discussions
- Use descriptive English naming for variables, methods, and classes

### **Code Organization**
- Follow the established folder structure:
  - `Core/Common/` - Base classes for shared functionality
  - `EndlessRunner/` - Game-specific implementations
  - `Events/` - Event system classes
  - `StateManagement/` - State management systems
  - `InputManagement/` - Input handling systems

### **Naming Conventions**
- Use **PascalCase** for classes, methods, and properties
- Use **camelCase** for variables and parameters
- Use **UPPER_CASE** for constants
- Prefix private fields with underscore: `_privateField`
- Use descriptive names that explain purpose

### **Performance Guidelines**
- Target 60 FPS performance
- Optimize memory usage (< 100MB RAM)
- Use object pooling for frequently created/destroyed objects
- Implement lazy evaluation where appropriate
- Monitor performance with BasePerformanceManager

## üèóÔ∏è Implementation Rules

### **Base Class Usage**
- Always extend appropriate base classes from `Core/Common/`
- Implement abstract methods properly
- Follow the template method pattern
- Maintain consistency across mini-games

### **Event System**
- Use EventBus for all inter-system communication
- Create specific event classes for different game actions
- Subscribe to events in constructors or initialization methods
- Publish events for significant game state changes

### **State Management**
- Use BaseGameStateManager<T> for state management
- Define clear transition rules
- Validate state transitions
- Log state changes for debugging

### **Input Handling**
- Extend BaseInputManager for input systems
- Implement command pattern for input actions
- Support both mouse/touch and keyboard input
- Lock/unlock input appropriately during game states

### **Error Handling**
- Use BaseErrorHandler for consistent error handling
- Implement safe execution patterns
- Validate configurations and animations
- Provide meaningful error messages

## üéÆ Game-Specific Rules

### **EndlessRunner Implementation**
- Use RunnerGameState enum for game states
- Implement RunnerStateManager extending BaseGameStateManager
- Create RunnerInputManager for 3D input handling
- Use PlayerController for player movement and physics
- Implement WorldGenerator for procedural level generation
- Use ScoreManager for scoring and high score tracking

### **3D Movement System**
- Implement constant forward movement
- Support lateral movement based on input
- Handle jumping with physics (Rigidbody)
- Implement sliding mechanics
- Use collision detection for obstacles and collectibles

### **World Generation**
- Use chunk-based level generation
- Implement spawn/despawn system for performance
- Create modular chunk prefabs
- Support procedural obstacle placement
- Optimize memory usage with object pooling

## üìä Quality Standards

### **Code Quality Metrics**
- SOLID principles compliance
- Maintainability: Easy to modify and extend
- Testability: Each system independently testable
- Scalability: Easy to add new features
- Consistency: Same patterns across all mini-games

### **Performance Metrics**
- 60 FPS on target devices
- < 100MB RAM usage
- < 3 seconds initial load time
- < 100ms input lag
- No frame drops during gameplay

### **Documentation Requirements**
- Comment all public methods and classes
- Document complex algorithms
- Explain design decisions in comments
- Keep README files updated

## üîß Development Workflow

### **Implementation Priority**
1. **Foundation First**: Build core systems before features
2. **Test Early**: Write tests for each system
3. **Iterate**: Refactor based on testing feedback
4. **Optimize**: Performance optimization after functionality
5. **Polish**: UI and user experience last

### **Code Review Checklist**
- [ ] Follows naming conventions
- [ ] Uses appropriate base classes
- [ ] Implements event-driven communication
- [ ] Includes proper error handling
- [ ] Maintains performance standards
- [ ] Includes necessary comments
- [ ] Follows SOLID principles

## üöÄ Success Criteria

### **Technical Success**
- Clean, readable code structure
- Proper inheritance from base classes
- Event-driven architecture implementation
- Performance targets met
- Memory usage optimized

### **Gameplay Success**
- Responsive input system
- Smooth 3D movement
- Engaging endless runner mechanics
- Scalable world generation
- Consistent user experience

---

*These rules ensure consistent, high-quality code development for the EndlessRunner project while maintaining the hybrid core systems architecture.*
